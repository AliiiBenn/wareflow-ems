# [CRITICAL] Path Traversal Vulnerability in File Upload

## Type
**Security Vulnerability**

## Severity
**CRITICAL** - CVE potential, allows unauthorized file system access

## Affected Components
- `src/ui_ctk/forms/caces_form.py` (lines 254-265)
- `src/ui_ctk/forms/medical_form.py` (lines 292-303)
- `src/employee/validators.py` (lines 145-154) - partial protection

## Description
The application allows users to select document paths for CACES certifications and medical visits, but does not validate or sanitize these paths. This creates a critical security vulnerability where malicious users could:
- Access files outside the intended directory
- Read arbitrary files from the system
- Potentially write to arbitrary locations (if feature added later)
- Perform directory traversal attacks

While `external_id` has path traversal validation in `validators.py`, the document upload functionality in forms has NO validation.

## Vulnerable Code Examples

### caces_form.py:254-265
```python
def browse_document(self):
    """Open file browser for document selection."""
    from tkinter import filedialog

    file_path = filedialog.askopenfilename(
        title="Select CACES Certificate",
        filetypes=[("PDF Files", "*.pdf"), ("All Files", "*.*")]
    )

    if file_path:
        # NO VALIDATION - path taken as-is!
        self.document_path_var.set(file_path)
```

### medical_form.py:292-303
```python
def browse_document(self):
    """Open file browser for medical visit document."""
    from tkinter import filedialog

    file_path = filedialog.askopenfilename(
        title="Select Medical Certificate",
        filetypes=[("PDF Files", "*.pdf"), ("All Files", "*.*")]
    )

    if file_path:
        # NO VALIDATION - path taken as-is!
        self.document_path_var.set(file_path)
```

## Attack Vectors
An attacker could:
1. Select a file with path traversal sequences: `../../etc/passwd`
2. Use Windows UNC paths: `\\evil-server\share\malware.exe`
3. Use absolute paths: `C:\Windows\System32\config\SAM`
4. Inject special characters to break file operations

## Impact Assessment
- **Confidentiality**: HIGH - Can read sensitive files
- **Integrity**: MEDIUM - Could corrupt data if write operations added
- **Availability**: LOW - Does not crash application
- **Accountability**: HIGH - Cannot trace who accessed what

## Proof of Concept
1. Open CACES form
2. Click "Browse..." for document
3. In file dialog, type: `../../.env` (or any sensitive file)
4. File path accepted and stored in database
5. Path displayed in UI - attacker knows file exists

## Proposed Solution

### Option 1: Whitelist Allowed Directory (Recommended)
```python
import os
from pathlib import Path

ALLOWED_DOCUMENTS_DIR = Path("documents/")  # Centralized document storage

def validate_document_path(file_path: str) -> tuple[bool, str]:
    """
    Validate document path is within allowed directory.

    Returns:
        (is_valid, error_message)
    """
    path = Path(file_path).resolve()

    # Check if within allowed directory
    try:
        path.relative_to(ALLOWED_DOCUMENTS_DIR.resolve())
        return True, None
    except ValueError:
        return False, "File must be within documents directory"

    # Additional checks
    if not path.exists():
        return False, "File does not exist"

    if not path.is_file():
        return False, "Path must be a file, not a directory"

    # Check file extension
    allowed_extensions = {'.pdf', '.png', '.jpg', '.jpeg'}
    if path.suffix.lower() not in allowed_extensions:
        return False, f"Only {', '.join(allowed_extensions)} files allowed"

    # Check file size (max 10MB)
    size_mb = path.stat().st_size / (1024 * 1024)
    if size_mb > 10:
        return False, "File size must be less than 10MB"

    return True, None
```

### Option 2: Copy Files to Secure Storage
Instead of storing paths, copy uploaded files to a secure documents directory:
```python
import shutil
from pathlib import Path
import uuid

DOCUMENTS_DIR = Path("documents/")

def save_document(source_path: str) -> str:
    """
    Save document to secure storage with unique filename.

    Args:
        source_path: Original file path

    Returns:
        New secure file path
    """
    source = Path(source_path)
    documents_dir = DOCUMENTS_DIR.resolve()
    documents_dir.mkdir(parents=True, exist_ok=True)

    # Generate unique filename
    unique_name = f"{uuid.uuid4()}_{source.name}"
    dest_path = documents_dir / unique_name

    # Copy file
    shutil.copy2(source_path, dest_path)

    return str(dest_path)
```

### Option 3: Use File Content Validation
Add magic number verification to ensure file type matches extension:
```python
import magic

def validate_file_content(file_path: str) -> bool:
    """Validate file type by checking magic numbers."""
    mime = magic.Magic(mime=True)
    file_type = mime.from_file(file_path)

    allowed_types = ['application/pdf', 'image/png', 'image/jpeg']
    return file_type in allowed_types
```

## Implementation Plan
1. Create `src/utils/file_validation.py` with validation functions
2. Update `caces_form.py` to validate paths before saving
3. Update `medical_form.py` to validate paths before saving
4. Add tests for path traversal attempts
5. Add tests for file content validation
6. Update documentation

## Files to Modify
- `src/utils/file_validation.py` (new)
- `src/ui_ctk/forms/caces_form.py`
- `src/ui_ctk/forms/medical_form.py`
- `tests/test_file_validation.py` (new)

## Testing Requirements
- Test path traversal with `../`
- Test path traversal with `..\\`
- Test with absolute paths
- Test with UNC paths
- Test with special characters
- Test with oversized files
- Test with disallowed file types
- Test with non-existent files

## Related Issues
- #004: File upload validation missing (broader file upload issue)

## References
- OWASP Path Traversal: https://owasp.org/www-community/attacks/Path_Traversal
- CWE-22: Improper Limitation of a Path Name to a Restricted Directory ('Path Traversal')
- Python `pathlib` documentation: https://docs.python.org/3/library/pathlib.html

## Priority
**CRITICAL** - Must fix before production deployment

## Estimated Effort
2-3 hours (including tests)

## Mitigation
While waiting for fix:
- Document upload feature should be disabled
- Documents should be managed outside the application
- Add warning in documentation about file upload risks
